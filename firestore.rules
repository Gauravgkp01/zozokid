/**
 * This ruleset enforces a strict user-ownership security model for the KidTube Safe application.
 *
 * Core Philosophy:
 * The security model is centered around "Parent" and "Teacher" user roles. Each parent has exclusive control over their own data tree (child profiles, analytics). Teachers can create classes and can be granted access to view specific child profiles by parents.
 *
 * Data Structure:
 * All user-specific data is hierarchically nested under the `/parents/{parentId}` path, where `{parentId}` is the authenticated user's UID. This structure allows for simple and performant path-based security rules. Global, shared data, such as YouTube channel information and content categories, are stored in separate top-level collections (`/channels`, `/contentTypes`) and are configured to be read-only for all authenticated users.
 *
 * Key Security Decisions:
 * - Strict Ownership: A user can only access documents where their UID matches the `{parentId}` or `{teacherId}` in the document path.
 * - Role-Based Access: Teachers can be granted read access to child profiles via the `sharedWithTeacherIds` field.
 * - No User Enumeration: Listing the top-level `/parents` or `/teachers` collection is explicitly disallowed.
 * - Default Deny: Any operation not explicitly granted is denied.
 *
 * Denormalization for Authorization:
 * To create simpler and more performant rules, this ruleset relies on denormalized ownership fields. For example, `ChildProfile` documents contain a `parentId` field. This allows rules to verify ownership by inspecting the document being written, avoiding slow and costly `get()` calls to parent documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Combines ownership check with a check that the document already exists.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Validates the core, immutable fields of a Parent document on creation.
    function hasValidParentDataOnCreate(parentId) {
      let data = request.resource.data;
      return data.id == parentId
          && data.externalAuthId == parentId;
    }

    // Enforces immutability of key relational fields for a Parent document on update.
    function hasValidParentDataOnUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id
          && data.externalAuthId == resource.data.externalAuthId;
    }
    
    // Validates the core fields for a Teacher document on creation.
    function hasValidTeacherDataOnCreate(teacherId) {
      let data = request.resource.data;
      return data.id == teacherId && data.externalAuthId == teacherId;
    }

    // Enforces immutability for key fields of a Teacher document on update.
    function hasValidTeacherDataOnUpdate() {
        let data = request.resource.data;
        return data.id == resource.data.id && data.externalAuthId == resource.data.externalAuthId;
    }

    // Validates the parentId link on ChildProfile creation.
    function hasValidChildProfileDataOnCreate(parentId) {
      return request.resource.data.parentId == parentId;
    }

    // Enforces immutability of the parentId link on ChildProfile update.
    function hasValidChildProfileDataOnUpdate() {
      return request.resource.data.parentId == resource.data.parentId;
    }
    
    // Validates relational integrity for a VideoWatchEvent on creation.
    function hasValidWatchEventDataOnCreate(parentId, childProfileId) {
      let data = request.resource.data;
      return data.parentId == parentId
          && data.childProfileId == childProfileId
          && data.channelTitle != null;
    }
    
    // Enforces immutability of relational links for a VideoWatchEvent on update.
    function hasValidWatchEventDataOnUpdate() {
      return request.resource.data.parentId == resource.data.parentId
          && request.resource.data.childProfileId == resource.data.childProfileId;
    }

    // Validates ownership for a new Class.
    function hasValidClassDataOnCreate() {
        return request.resource.data.teacherId == request.auth.uid;
    }

    // Enforces immutability of the teacherId for a Class.
    function hasValidClassDataOnUpdate() {
        return request.resource.data.teacherId == resource.data.teacherId;
    }
    
    function hasValidVideoDataOnCreate(parentId) {
      let data = request.resource.data;
      return data.parentId == parentId
          && data.channelId != null
          && data.channelTitle != null;
    }
    
    function hasValidVideoDataOnUpdate() {
      let data = request.resource.data;
      return data.parentId == resource.data.parentId
          && data.channelId == resource.data.channelId;
    }

    /**
     * @description Manages parent user profiles.
     */
    match /parents/{parentId} {
      allow get: if isOwner(parentId);
      allow list: if false;
      allow create: if isOwner(parentId) && hasValidParentDataOnCreate(parentId);
      allow update: if isExistingOwner(parentId) && hasValidParentDataOnUpdate();
      allow delete: if isExistingOwner(parentId);

      /**
       * @description Manages child profiles owned by a parent. A parent has full control. A teacher can read if they are in the `sharedWithTeacherIds` list.
       */
      match /childProfiles/{childProfileId} {
        allow get: if isOwner(parentId) || (isSignedIn() && resource.data.sharedWithTeacherIds.hasAny([request.auth.uid]));
        allow list: if isOwner(parentId);
        allow create: if isOwner(parentId) && hasValidChildProfileDataOnCreate(parentId);
        allow update: if isExistingOwner(parentId) && hasValidChildProfileDataOnUpdate();
        allow delete: if isExistingOwner(parentId);

        /**
         * @description Manages analytics data (video watch events) for a specific child profile.
         */
        match /videoWatchEvents/{eventId} {
          allow get: if isOwner(parentId);
          allow list: if isOwner(parentId);
          allow create: if isOwner(parentId) && hasValidWatchEventDataOnCreate(parentId, childProfileId);
          allow update: if isExistingOwner(parentId) && hasValidWatchEventDataOnUpdate();
          allow delete: if isExistingOwner(parentId);
        }
      }
      
      /**
       * @description Manages the queue of parent-approved videos.
       */
      match /videoQueue/{videoId} {
        allow get: if isOwner(parentId);
        allow list: if isOwner(parentId);
        allow create: if isOwner(parentId) && hasValidVideoDataOnCreate(parentId);
        allow update: if isOwner(parentId) && hasValidVideoDataOnUpdate();
        allow delete: if isOwner(parentId);
      }
    }
    
    /**
     * @description Manages teacher user profiles.
     */
    match /teachers/{teacherId} {
      allow get: if isOwner(teacherId);
      allow list: if false;
      allow create: if isOwner(teacherId) && hasValidTeacherDataOnCreate(teacherId);
      allow update: if isExistingOwner(teacherId) && hasValidTeacherDataOnUpdate();
      allow delete: if isExistingOwner(teacherId);
    }
    
    /**
     * @description Global collection for classes. Only the creating teacher can manage their class.
     * List operations are secured by the `get` rule. The client MUST filter by `teacherId`.
     */
    match /classes/{classId} {
      allow get: if isSignedIn() && resource.data.teacherId == request.auth.uid;
      allow create: if isSignedIn() && hasValidClassDataOnCreate();
      allow update: if isSignedIn() && resource.data.teacherId == request.auth.uid && hasValidClassDataOnUpdate();
      allow delete: if isSignedIn() && resource.data.teacherId == request.auth.uid;
    }

    /**
     * @description Manages requests for a child to join a class.
     * `read` operations are secured via the `viewers` array. The client MUST query
     * using `where('viewers', 'array-contains', request.auth.uid)`.
     */
    match /classJoinRequests/{requestId} {
      allow read: if isSignedIn() && request.auth.uid in resource.data.viewers;
      allow create: if isSignedIn() && request.resource.data.parentId == request.auth.uid && request.auth.uid in request.resource.data.viewers;
      allow update: if isSignedIn() && resource.data.teacherId == request.auth.uid && request.auth.uid in resource.data.viewers;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.viewers;
    }

    /**
     * @description Global collection of YouTube channel metadata. Read-only for authenticated users.
     */
    match /channels/{channelId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Global collection of predefined content categories. Read-only for authenticated users.
     */
    match /contentTypes/{contentTypeId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
